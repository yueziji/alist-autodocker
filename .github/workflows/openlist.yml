# .github/workflows/manual-build-openlist-v4-simple.yml

name: Manual Build OpenList v4 (Simple)

on:
  # 仅允许通过 GitHub Actions UI 手动触发
  workflow_dispatch:

jobs:
  build_and_push_simple:
    name: Build and Push Base Docker Image
    runs-on: ubuntu-latest
    permissions:
      # Docker a GCR/GHCR 需要 packages: write 权限
      packages: write

    steps:
      # 步骤 1: 检出 OpenListTeam/OpenList 仓库
      # !!! 您可以根据需要修改 ref 来构建不同的分支
      - name: Checkout OpenListTeam/OpenList Repository
        uses: actions/checkout@v4
        with:
          repository: 'OpenListTeam/OpenList'
          ref: 'main'
          fetch-depth: 0

      # 步骤 2: 获取仓库的 Commit SHA，用于 Docker 标签
      - name: Get Commit SHA
        id: get_sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      # 步骤 3: 设置 Docker 元数据，使用 Commit SHA 作为唯一标签
      # !!! 重要: 将 'images' 修改为您自己的 Docker Hub 镜像名称
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: 'yueziji/testlist'
          tags: |
            type=raw,value=${{ steps.get_sha.outputs.sha }}

      # 步骤 4: 安装 Go 语言环境
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'

      # 步骤 5: 缓存 Musl 交叉编译工具链以加快构建速度
      # (完全复刻自原版工作流)
      - name: Cache Musl
        id: cache-musl
        uses: actions/cache@v4
        with:
          path: build/musl-libs
          key: docker-musl-libs-v2

      # 步骤 6: 如果缓存未命中，则下载 Musl 库
      # (完全复刻自原版工作流)
      - name: Download Musl Library
        if: steps.cache-musl.outputs.cache-hit != 'true'
        run: bash build.sh prepare docker-multiplatform
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 步骤 7: 【核心】编译所有平台二进制文件
      # 我们运行和原版工作流完全相同的命令。
      # build.sh 脚本会自动处理版本注入和前端文件下载。
      - name: Build Go Binaries (beta)
        run: |
          # 1. 只保留 amd64 平台
          export OS_ARCHES=(linux-amd64)
          # 2. 指定 amd64 对应的交叉编译器
          export CGO_ARGS=(x86_64-linux-musl-gcc)
          # 3. 清空专门用于 ARM 的数组，确保那部分循环不会执行
          export DOCKER_ARM_ARCHES=()

          # 4. 现在，像往常一样调用脚本。它将使用我们上面定义的、被缩减的数组。
          bash build.sh beta docker-multiplatform
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # 如果需要，可以覆盖前端仓库
          # FRONTEND_REPO: ${{ vars.FRONTEND_REPO }}

      # 步骤 8: 设置 QEMU 和 Docker Buildx (用于多平台镜像构建)
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 步骤 9: 登录到 DockerHub
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: yueziji
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 步骤 10: 【核心】构建并推送 Docker 镜像
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          # 使用为 CI/CD 设计的 Dockerfile.ci
          file: Dockerfile.ci
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # 构建所有平台，与原版工作流保持一致
          platforms: 'linux/amd64'
          # 硬编码构建参数，确保只构建 'base' 镜像
          build-args: |
            BASE_IMAGE_TAG=base
