# .github/workflows/manual-build-openlist-v4-simple.yml

name: Build Modified OpenList (with Self-Fixing Permissions)

on:
  # 仅允许通过 GitHub Actions UI 手动触发
  workflow_dispatch:

jobs:
  build_and_push_simple:
    name: Build and Push Self-Fixing Docker Image
    runs-on: ubuntu-latest
    permissions:
      # Docker a GCR/GHCR 需要 packages: write 权限
      packages: write

    steps:
      # 步骤 1: 检出 OpenListTeam/OpenList 仓库
      - name: Checkout OpenListTeam/OpenList Repository
        uses: actions/checkout@v4
        with:
          repository: 'OpenListTeam/OpenList'
          ref: 'main'
          fetch-depth: 0

      # 步骤 2: 获取仓库的 Commit SHA，用于 Docker 标签
      - name: Get Commit SHA
        id: get_sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      # 步骤 3: 设置 Docker 元数据，使用 Commit SHA 作为唯一标签
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: 'yueziji/testlist' # !!! 这里是您的镜像名称，保持不变
          tags: |
            type=raw,value=${{ steps.get_sha.outputs.sha }}
            type=raw,value=latest

      # 步骤 4: 安装 Go 语言环境
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'

      # 步骤 5: 缓存 Musl 交叉编译工具链以加快构建速度
      - name: Cache Musl
        id: cache-musl
        uses: actions/cache@v4
        with:
          path: build/musl-libs
          key: docker-musl-libs-v2

      # 步骤 6: 如果缓存未命中，则下载 Musl 库
      - name: Download Musl Library
        if: steps.cache-musl.outputs.cache-hit != 'true'
        run: bash build.sh prepare docker-multiplatform
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 步骤 7: 编译所有平台二进制文件
      - name: Build Go Binaries (beta)
        run: |
          sed -i "s/^  OS_ARCHES=.*/  OS_ARCHES=(linux-amd64)/" build.sh
          sed -i "s/^  CGO_ARGS=.*/  CGO_ARGS=(x86_64-linux-musl-gcc)/" build.sh
          sed -i "s/^  DOCKER_ARM_ARCHES=.*/  DOCKER_ARM_ARCHES=()/" build.sh
          echo "--- Patched build.sh content ---"
          grep -C 2 "OS_ARCHES" build.sh
          echo "------------------------------"
          bash build.sh beta docker-multiplatform
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      
      - name: "📝 Modify Dockerfile for Self-Fixing Permissions"
        run: |
          echo "--- Original Dockerfile.ci content ---"
          cat Dockerfile.ci
          echo "--------------------------------------"
          
          # 1. 删除 USER 指令，确保容器以 root 启动
          sed -i '/^USER \${USER}/d' Dockerfile.ci
          
          # 2. 将 CMD 指令替换为我们的自修复命令
          #    这个命令会先以 root 身份 chown，然后降权为 openlist 用户执行原始的 entrypoint
          sed -i '/^CMD/c\CMD [ "/bin/bash", "-c", "chown -R 1001:1001 /opt/openlist/data && su openlist -c /entrypoint.sh" ]' Dockerfile.ci

          echo "--- Modified Dockerfile.ci content ---"
          cat Dockerfile.ci
          echo "--------------------------------------"

      # 步骤 8: 设置 QEMU 和 Docker Buildx
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 步骤 9: 登录到 DockerHub
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: yueziji
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 步骤 10: 构建并推送 Docker 镜像 (现在会使用我们修改后的 Dockerfile.ci)
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          # 使用已被我们动态修改的 Dockerfile.ci
          file: Dockerfile.ci
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: 'linux/amd64'
          build-args: |
            BASE_IMAGE_TAG=base
